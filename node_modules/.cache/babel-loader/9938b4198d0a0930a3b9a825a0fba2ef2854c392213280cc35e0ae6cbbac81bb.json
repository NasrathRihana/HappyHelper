{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from \"react\";\nimport firebase from \"../../../utils/firebase\";\nconst useFetchUsers = (currentUserUid, setLoading) => {\n  _s();\n  // State for list of users, conversations, and filtered chats\n  const [users, setUsers] = useState([]);\n  const [conversations, setConversations] = useState([]);\n  const [filterChat, setfilterChat] = useState([]);\n  useEffect(() => {\n    const fetchUsers = async () => {\n      // Fetch all users from Firebase, except for the current user\n      const usersData = await getUsersFromFirebase(currentUserUid);\n      setUsers(usersData);\n\n      // Create an array of conversations based on current user's UID and other users' UID\n      const newConversations = createConversationsArray(usersData, currentUserUid);\n      setConversations(newConversations);\n\n      // Fetch chats/messages for each conversation and filter out empty ones\n      const filteredChats = await getFilteredChats(newConversations);\n      setfilterChat(filteredChats);\n\n      // Update the loading state\n      setLoading(false);\n    };\n    fetchUsers();\n  }, [currentUserUid, setLoading]);\n  return {\n    users,\n    conversations,\n    filterChat\n  };\n};\n\n// Function to fetch all users from Firebase, except for the current user\n_s(useFetchUsers, \"bU9QTYNZxeRiEOPnnO4CJriSLlQ=\");\nconst getUsersFromFirebase = async currentUserUid => {\n  const usersRef = firebase.firestore().collection(\"users\");\n  const snapshot = await usersRef.get();\n  return snapshot.docs.filter(doc => doc.id !== currentUserUid).map(doc => ({\n    ...doc.data(),\n    uid: doc.id\n  }));\n};\n\n// Function to create an array of conversations based on current user's UID and other users' UID\nconst createConversationsArray = (usersData, currentUserUid) => {\n  return usersData.map(user => {\n    const otherUid = user.uid;\n    const smallerUid = currentUserUid > otherUid ? currentUserUid : otherUid;\n    const biggerUid = currentUserUid > otherUid ? otherUid : currentUserUid;\n    // Concatenate UIDs in a specific order to create a unique conversation ID\n    return `${smallerUid}-${biggerUid}`;\n  });\n};\n\n// Function to fetch chats/messages for each conversation and filter out empty ones\nconst getFilteredChats = async conversations => {\n  const chatsRef = firebase.firestore().collection(\"chats\");\n  const filteredChats = [];\n  for (const conversation of conversations) {\n    // Fetch the last message for each conversation\n    const chatSnapshot = await chatsRef.doc(conversation).collection(\"messages\").orderBy(\"timestamp\", \"desc\") // Order by 'timestamp' field\n    .limit(1) // Limit to the last message\n    .get();\n\n    // If there are messages, add conversation to filtered chats array\n    if (!chatSnapshot.empty) {\n      const lastMessage = chatSnapshot.docs.map(doc => ({\n        ...doc.data(),\n        messageId: doc.id\n      }))[0]; // Get the first (and only) item from the array\n      filteredChats.push({\n        id: conversation,\n        lastMessage: lastMessage\n      });\n    }\n  }\n  return filteredChats;\n};\nexport default useFetchUsers;","map":{"version":3,"names":["useEffect","useState","firebase","useFetchUsers","currentUserUid","setLoading","_s","users","setUsers","conversations","setConversations","filterChat","setfilterChat","fetchUsers","usersData","getUsersFromFirebase","newConversations","createConversationsArray","filteredChats","getFilteredChats","usersRef","firestore","collection","snapshot","get","docs","filter","doc","id","map","data","uid","user","otherUid","smallerUid","biggerUid","chatsRef","conversation","chatSnapshot","orderBy","limit","empty","lastMessage","messageId","push"],"sources":["C:/Users/bashc/OneDrive/Documents/Kaar Documents/HappyHelperFinal/src/components/Chat/UserList/useFetchUsers.js"],"sourcesContent":["import { useEffect, useState } from \"react\";\r\nimport firebase from \"../../../utils/firebase\";\r\n\r\nconst useFetchUsers = (currentUserUid, setLoading) => {\r\n  // State for list of users, conversations, and filtered chats\r\n  const [users, setUsers] = useState([]);\r\n  const [conversations, setConversations] = useState([]);\r\n  const [filterChat, setfilterChat] = useState([]);\r\n\r\n  useEffect(() => {\r\n    const fetchUsers = async () => {\r\n      // Fetch all users from Firebase, except for the current user\r\n      const usersData = await getUsersFromFirebase(currentUserUid);\r\n      setUsers(usersData);\r\n\r\n      // Create an array of conversations based on current user's UID and other users' UID\r\n      const newConversations = createConversationsArray(\r\n        usersData,\r\n        currentUserUid\r\n      );\r\n      setConversations(newConversations);\r\n\r\n      // Fetch chats/messages for each conversation and filter out empty ones\r\n      const filteredChats = await getFilteredChats(newConversations);\r\n      setfilterChat(filteredChats);\r\n\r\n      // Update the loading state\r\n      setLoading(false);\r\n    };\r\n\r\n    fetchUsers();\r\n  }, [currentUserUid, setLoading]);\r\n\r\n  return { users, conversations, filterChat };\r\n};\r\n\r\n\r\n// Function to fetch all users from Firebase, except for the current user\r\nconst getUsersFromFirebase = async (currentUserUid) => {\r\n  const usersRef = firebase.firestore().collection(\"users\");\r\n  const snapshot = await usersRef.get();\r\n  return snapshot.docs\r\n    .filter((doc) => doc.id !== currentUserUid)\r\n    .map((doc) => ({ ...doc.data(), uid: doc.id }));\r\n};\r\n\r\n// Function to create an array of conversations based on current user's UID and other users' UID\r\nconst createConversationsArray = (usersData, currentUserUid) => {\r\n  return usersData.map((user) => {\r\n    const otherUid = user.uid;\r\n    const smallerUid = currentUserUid > otherUid ? currentUserUid : otherUid;\r\n    const biggerUid = currentUserUid > otherUid ? otherUid : currentUserUid;\r\n    // Concatenate UIDs in a specific order to create a unique conversation ID\r\n    return `${smallerUid}-${biggerUid}`;\r\n  });\r\n};\r\n\r\n// Function to fetch chats/messages for each conversation and filter out empty ones\r\nconst getFilteredChats = async (conversations) => {\r\n  const chatsRef = firebase.firestore().collection(\"chats\");\r\n  const filteredChats = [];\r\n\r\n  for (const conversation of conversations) {\r\n    // Fetch the last message for each conversation\r\n    const chatSnapshot = await chatsRef\r\n      .doc(conversation)\r\n      .collection(\"messages\")\r\n      .orderBy(\"timestamp\", \"desc\") // Order by 'timestamp' field\r\n      .limit(1) // Limit to the last message\r\n      .get();\r\n\r\n    // If there are messages, add conversation to filtered chats array\r\n    if (!chatSnapshot.empty) {\r\n      const lastMessage = chatSnapshot.docs.map((doc) => ({\r\n        ...doc.data(),\r\n        messageId: doc.id,\r\n      }))[0]; // Get the first (and only) item from the array\r\n      filteredChats.push({ id: conversation, lastMessage: lastMessage });\r\n    }\r\n  }\r\n\r\n  return filteredChats;\r\n};\r\n\r\n\r\nexport default useFetchUsers;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}